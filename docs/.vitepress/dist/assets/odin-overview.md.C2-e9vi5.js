import{_ as o,c as i,o as a,ae as n}from"./chunks/framework.CBTkueSR.js";const g=JSON.parse('{"title":"odin-overview","description":"Document from d:\\\\Documents\\\\odin-projects\\\\explore-odin\\\\docs\\\\odin-overview.md","frontmatter":{"title":"odin-overview","description":"Document from d:\\\\Documents\\\\odin-projects\\\\explore-odin\\\\docs\\\\odin-overview.md","date":"2025-10-05T00:00:00.000Z"},"headers":[],"relativePath":"odin-overview.md","filePath":"odin-overview.md"}'),r={name:"odin-overview.md"};function t(s,e,l,d,c,m){return a(),i("div",null,[...e[0]||(e[0]=[n('<h1 id="odin-programming-language-overview" tabindex="-1">Odin Programming Language Overview <a class="header-anchor" href="#odin-programming-language-overview" aria-label="Permalink to &quot;Odin Programming Language Overview&quot;">​</a></h1><h2 id="installation" tabindex="-1">Installation <a class="header-anchor" href="#installation" aria-label="Permalink to &quot;Installation&quot;">​</a></h2><p>To install Odin, download the latest release from <a href="https://github.com/odin-lang/Odin/releases" target="_blank" rel="noreferrer">GitHub Releases</a>. Ensure you have the required compilers: MSVC on Windows, Clang on macOS/Linux.</p><p>For detailed instructions, see the <a href="https://odin-lang.org/docs/install/" target="_blank" rel="noreferrer">official install guide</a>.</p><h2 id="what-odin-is-good-for" tabindex="-1">What Odin is Good For <a class="header-anchor" href="#what-odin-is-good-for" aria-label="Permalink to &quot;What Odin is Good For&quot;">​</a></h2><p>Odin is a general-purpose, compiled systems programming language designed for high performance, modern systems, and data-oriented programming. It&#39;s positioned as a modern alternative to C, emphasizing simplicity, orthogonality, and joy in programming. It&#39;s particularly good for:</p><ul><li><strong>Systems programming</strong>: Low-level control over memory, allocators, and hardware.</li><li><strong>High-performance applications</strong>: Real-time simulations, games, and multimedia (e.g., used in EmberGen for 3D fluid simulations).</li><li><strong>Data-oriented programming</strong>: Features like SOA (Struct of Arrays), array programming, and custom allocators for efficient data handling.</li><li><strong>Cross-platform development</strong>: Supports bindings to C libraries, graphics APIs (OpenGL, Vulkan), and has a rich standard library.</li></ul><h2 id="syntax-comparison" tabindex="-1">Syntax Comparison <a class="header-anchor" href="#syntax-comparison" aria-label="Permalink to &quot;Syntax Comparison&quot;">​</a></h2><p>Odin&#39;s syntax is procedural and C-like, with influences from Go and Pascal. It uses <code>::</code> for declarations (constants/procedures), <code>:=</code> for inference, and has explicit typing. Key differences from TypeScript, Lua, and Rust:</p><ul><li><p><strong>vs. TypeScript</strong> (typed JavaScript for web/apps):</p><ul><li>Odin is compiled and static-typed with no runtime (no JS-like dynamism or GC). Syntax is more verbose and low-level: e.g., <code>proc</code> instead of <code>function</code>, explicit pointers (<code>^T</code>), and no classes/objects (uses structs/unions).</li><li>No closures or async/await; focuses on procedures and manual memory.</li><li>Example: Odin&#39;s <code>main :: proc() { fmt.println(&quot;Hello&quot;) }</code> vs. TS&#39;s <code>function main() { console.log(&quot;Hello&quot;); }</code>.</li></ul></li><li><p><strong>vs. Lua</strong> (scripting, dynamic, embedded):</p><ul><li>Odin is compiled and static-typed; Lua is interpreted and dynamic. Odin&#39;s syntax is stricter: requires types, no global variables by default, and uses <code>::</code> for constants/procedures.</li><li>No tables/metatables; uses arrays, maps, structs. Procedures are <code>proc</code> with explicit returns.</li><li>Example: Odin&#39;s <code>x: int = 42</code> vs. Lua&#39;s <code>local x = 42</code> (inferred).</li></ul></li><li><p><strong>vs. Rust</strong> (memory-safe systems language):</p><ul><li>Similar low-level focus, but Odin&#39;s syntax is simpler: no ownership/borrowing rules, no lifetimes. Uses <code>proc</code> instead of <code>fn</code>, <code>^T</code> for pointers (like C), and explicit overloading.</li><li>Less safe by default (no borrow checker); relies on manual management. Supports generics (parapoly) but with explicit overloading.</li><li>Example: Odin&#39;s <code>x: ^int = &amp;y</code> vs. Rust&#39;s <code>let x: &amp;i32 = &amp;y</code> (with borrowing).</li></ul></li></ul><p>Odin emphasizes readability and orthogonality, with features like implicit context for allocators and <code>defer</code> for cleanup.</p><h2 id="footguns-common-pitfalls" tabindex="-1">Footguns (Common Pitfalls) <a class="header-anchor" href="#footguns-common-pitfalls" aria-label="Permalink to &quot;Footguns (Common Pitfalls)&quot;">​</a></h2><ul><li><strong>Manual memory management</strong>: No GC; forgetting to <code>delete</code> or <code>free</code> leads to leaks. Use tracking allocators in debug mode.</li><li><strong>Pointers and safety</strong>: Like C, dereferencing <code>nil</code> or invalid pointers causes segfaults. Bounds checking is on by default but can be disabled for perf.</li><li><strong>Type assertions on unions/any</strong>: <code>v.(Type)</code> panics if wrong type; use <code>v.?</code> or <code>or_else</code> for safety.</li><li><strong>Implicit context</strong>: Allocators/loggers are global per scope; forgetting to set context in foreign code can fail silently.</li><li><strong>Array programming/SOA</strong>: Swizzling (<code>a.xy</code>) or SOA syntax can confuse if unfamiliar; easy to mix up AOS vs. SOA layouts.</li><li><strong>Strict typing</strong>: Few implicit conversions; e.g., <code>int</code> to <code>f32</code> requires explicit cast, leading to compile errors.</li><li><strong>Foreign bindings</strong>: Calling conventions (e.g., <code>stdcall</code>) must match C libs; mismatches cause crashes.</li><li><strong>Parametric polymorphism</strong>: Explicit overloading can lead to verbose code; <code>where</code> clauses are powerful but complex.</li><li><strong>No overflow checks</strong>: Integers wrap silently; use <code>#bounds_check</code> or external checks.</li></ul>',13)])])}const u=o(r,[["render",t]]);export{g as __pageData,u as default};

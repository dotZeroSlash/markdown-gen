# Perplexity Query Record

Generated on: 2025-10-11 12:19:56

**ID:** 68e1d5b41fd01eaed17e28a4

**id:** 1

**timestamp:** 2025-10-04T19:19:32

**query:**

How do I use rust macros?

**answer:** Rust macros enable code generation at compile time through two main approaches: declarative macros using macro_rules! and procedural macros that operate on token streams.logrocket+1

Declarative Macros

Declarative macros use pattern matching syntax similar to match expressions to transform code. They're defined with macro_rules! and provide a straightforward way to eliminate repetitive code.flinect+1

Basic Syntax
rust
macro_rules! add {
    ($a:expr, $b:expr) => {
        {
            $a + $b
        }
    }
}

fn main() {
    let result = add!(1, 2);
}


The macro matches expressions using fragment specifiers like expr (expression), ident (identifier), ty (type), path, and tt (token tree). The $ prefix indicates metavariables that capture matched syntax.flinect

Repetitions

Macros can handle repeated patterns using $(...) followed by separators and operators like * for zero or more repetitions:flinect

rust
macro_rules! say_hello {
    ($($name:expr),*) => {
        $(
            println!("Hello, {}!", $name);
        )*
    }
}


This allows flexible invocations handling multiple arguments of the same pattern.dev

Procedural Macros

Procedural macros execute arbitrary Rust code at compile time, taking token streams as input and producing token streams as output. They come in three types:freecodecamp+2

Function-like macros: custom!(...)

Derive macros: #[derive(CustomDerive)]

Attribute macros: #[CustomAttribute]

Setup Requirements

Procedural macros must be defined in their own crate with special configuration in Cargo.toml:earthly+1

text
[lib]
proc-macro = true


Each macro type uses specific attributes: #[proc_macro], #[proc_macro_derive], or #[proc_macro_attribute]. The macros operate on the abstract syntax tree and typically use crates like syn for parsing and quote for code generation.developerlife+1

When to Use Macros

Use declarative macros for pattern-based code generation and reducing boilerplate. Choose procedural macros when needing custom derives, attribute syntax, or complex AST manipulation. Declarative macros compile faster and have simpler dependency chains, while procedural macros offer more flexibility for complex transformations.rust-lang.github+3

**url:** https://www.perplexity.ai/search/how-do-i-use-rust-macros-oqIP_fZARi2hSNDRCK6qxA

**model:** Grok 4

